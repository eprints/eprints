#!/usr/bin/perl -w -I/opt/eprints3/perl_lib

######################################################################
#
#  __COPYRIGHT__
#
# Copyright 2000-2008 University of Southampton. All Rights Reserved.
# 
#  __LICENSE__
#
######################################################################

=pod

=head1 NAME

B<import> - Import a file using an import plugin.

=head1 SYNOPSIS

B<import> I<repository_id> [B<options>] I<dataset>

B<import> I<repository_id> [B<options>] I<dataset> I<plugin> I<filename> 

=head1 DESCRIPTION

This command imports a set of EPrints from a file into the given dataset.

=head1 ARGUMENTS

=over 8

=item I<repository_id> 

The ID of the EPrint repository to import to.

=item I<dataset>

The name of the dataset to import into, such as "eprint","archive", "subject" or "user".

Please note that for the "subject" dataset, you are probably better off using the import_subjects tool which will empty the dataset before importing.

=item I<plugin>

The id of the input plugin to use. This should not include the leading "Import::". Examples: BibTeX, XML.

If this is ommited or an invalid plugin is requested, then 'import' will list all plugins compatible with the dataset and exit.

=back

=head1 OPTIONS

=over 8

=item B<--user USERID/USERNAME> 

For eprint datasets only. (not user or subject). 

Sets the userid/username of the user in the system who will own the imported records.

Usually required for importing EPrint records. This may not be required if the import format contains the userid value, eg. an import in the EPrints 3 XML format.

If this is an integer then it is assumed to be the userid of the user, otherwise it is assumed to be the username.

You may wish to create one or more "bulk import" users and make imported eprint records belong to them.

=item B<--parse-only>

Don't import, just check the file.

=item B<--migration>

Turn on all the options needed to correctly import an XML data file exported from version 2, using the migration toolkit. This is the same as using --enable-import-ids --enable-import-datestamps --enable-file-imports --force

=item B<--enable-import-ids>

By default import will generate a new eprintid, or userid for each record. This option tells it to use the id spcified in the imported data. This is generally used for importing into a new repository from an old one.

=item B<--enable-import-datestamps>

Normally import will set the datestamp the the time the eprint was imported. This option causes it to take the datestamp from the imported data, if available.

=item B<--enable-file-imports>

Allow the imported data to import files from the local filesystem. This can obviously be seen as a security hole if you don't trust the data you are importing.
This sets the "enable_file_imports" configuration option for this session only.

=item B<--force>

Don't ask any questions, just do it!

=item B<--help>

Print a brief help message and exit.

=item B<--man>

Print the full manual page and then exit.

=item B<--quiet>

Be vewwy vewwy quiet. This option will supress all output unless an error occurs.

=item B<--verbose>

Explain in detail what is going on.
May be repeated for greater effect.

Shows why a plugin is disabled.

=item B<--version>

Output version information and exit.

=back   


__GENERICPOD__

=cut

{
package bin::import::Handler;

use vars qw( %COLORS );

eval "use Term::ANSIColor qw()";

%COLORS = $@ ?
()
: (
	reset => "reset",
	error => "bold red",
	warning => "bold yellow",
);

sub color
{
	my( $type ) = @_;

	return exists $COLORS{$type} ? Term::ANSIColor::color( $COLORS{$type} ) : "";
}

sub new
{
    my( $class, %self ) = @_;

    $self{wrote} = 0;
    $self{parsed} = 0;
	$self{ids} = [];

    bless \%self, $class;
}

sub message
{
    my( $self, $type, $msg ) = @_;

	print STDERR color($type);
	$msg = EPrints::Utils::tree_to_utf8( $msg );
	print STDERR "$msg\n";
	print STDERR color('reset');
}

sub parsed
{
    my( $self, $epdata ) = @_;

    $self->{parsed}++;

	if( $self->{scripted} )
	{
		print "EPRINTS_IMPORT: ITEM_PARSED\n";
	}
}

sub object
{
    my( $self, $dataset, $dataobj ) = @_;

    $self->{wrote}++;

	push @{$self->{ids}}, $dataobj->get_id;

	if( $self->{session}->get_noise > 1 )
	{
		print STDERR "Imported ".$dataset->id." ".$dataobj->get_id."\n";
	}

	if( $self->{scripted} )
	{
		print "EPRINTS_IMPORT: ITEM_IMPORTED ".$dataobj->get_id."\n";
	}
}
}

use Getopt::Long;
use Pod::Usage;
use strict;

use EPrints;

my $version = 0;
my $verbose = 0;
my $quiet = 0;
my $purge = 1;
my $help = 0;
my $man = 0;
my $force = 0;
my $single = 0;
my $scripted = 0;
my $user = undef;
my $parse_only = 0;
my $enable_file_imports = 0;
my $enable_import_ids = 0;
my $enable_import_datestamps = 0;
my $migration = 0;

GetOptions( 
	'help|?' => \$help,
	'man' => \$man,
	'force' => \$force,
	'user=s' => \$user,
	'version' => \$version,
	'verbose+' => \$verbose,
	'silent' => \$quiet,
	'quiet' => \$quiet,
	'scripted' => \$scripted,
	'single' => \$single,
	'parse-only' => \$parse_only,
	'enable-file-imports' => \$enable_file_imports,
	'enable-import-ids' => \$enable_import_ids,
	'enable-import-datestamps' => \$enable_import_datestamps,
	'migration' => \$migration,
) || pod2usage( 2 );
EPrints::Utils::cmd_version( "export_xml" ) if $version;
pod2usage( 1 ) if $help;
pod2usage( -exitstatus => 0, -verbose => 2 ) if $man;
pod2usage( 2 ) if( scalar @ARGV != 2 && scalar @ARGV !=4 );
my $noise = 1;
$noise = 0 if( $quiet );
$noise = 1+$verbose if( $verbose );

if( $migration )
{
	$force = 1;
	$enable_file_imports = 1;
	$enable_import_ids = 1;
	$enable_import_datestamps = 1;
}

if( $scripted ) { $noise = 0; }
# Set STDOUT to auto flush (without needing a \n)
$|=1;

my $repository_id = shift @ARGV;
my $datasetid = shift @ARGV;
my $ipluginid = shift @ARGV;
my $filename = shift @ARGV;

my $session = new EPrints::Session( 1, $repository_id, $noise );
exit( 1 ) unless defined $session;

if( $enable_file_imports )
{
	# doesn't use a setter method!
	$session->get_repository->{config}->{enable_file_imports} = 1;
}
if( $enable_import_ids ) 
{ 
	# doesn't use a setter method!
	$session->get_repository->{config}->{enable_import_ids} = 1;
}
if( $enable_import_datestamps ) 
{ 
	# doesn't use a setter method!
	$session->get_repository->{config}->{enable_import_datestamps} = 1;
}


my $ds = $session->get_repository->get_dataset( $datasetid ) ;
if( !defined $ds )
{
	print STDERR "Unknown Dataset ID: $datasetid\n";
	$session->terminate;
	exit 1;
}

my $userobj;
if( defined $user )
{
	if( $user =~ m/^\d+/ )
	{
		$userobj = EPrints::DataObj::User->new( $session, $user );
	}
	else
	{
		$userobj = EPrints::DataObj::User::user_with_username( $session, $user );
	}
	if( !defined $userobj )
	{
		print STDERR "Can't find user with userid/username [$user]\n";
		exit 1;
	}
}

if( !defined $ipluginid )
{
	my @list_plugins = $session->plugin_list( 
					type=>"Import",
					can_produce=>"list/".$ds->confid );
	my @dataobj_plugins = $session->plugin_list( 
					type=>"Import",
					can_produce=>"dataobj/".$ds->confid );
	my %p = ();
	my %l = ();
	my %d = ();
	foreach( @list_plugins ) { $p{$_} = $_; $l{$_} = 1; }
	foreach( @dataobj_plugins ) { $p{$_} = 1; $d{$_} = 1; }
	print "Available input formats:\n";
	foreach my $a_plugin_id ( sort keys %p ) 
	{
		my $a_plugin = $session->plugin( $a_plugin_id );
		printf( "% 16s", $a_plugin->get_subtype);
		print ": ".$a_plugin->get_name();
		if( $l{$a_plugin_id} && !$d{$a_plugin_id} )
		{
			print " (List input only)";
		}
		if( $d{$a_plugin_id} && !$l{$a_plugin_id} )
		{
			print " (Single object input only)";
		}
		if( $a_plugin->broken )
		{
			print " (DISABLED)";
			print "\n** Disabled because: ".$a_plugin->error_message if( $noise > 1 );
		}
		print "\n";
	}
	$session->terminate();
	exit;
}

if( !defined $user && $ds->confid eq "eprint" && !$force )
{
	print <<END;
Warning! You haven't specified a user id to own these eprints, 
That's OK, assuming the input file specifies the userid for each eprint. 
(you can supress this check with --force).
END
	unless( EPrints::Utils::get_input_confirm( "Continue?", 1 ) )
	{
		$session->terminate();
		exit 1;
	}
}

my $handler = bin::import::Handler->new(
	session => $session,
	scripted => $scripted,
);

my $pluginid = "Import::".$ipluginid;
my $plugin = $session->plugin( $pluginid, parse_only=>$parse_only, Handler=>$handler );

if( !defined $plugin )
{
	# This warning is already generated by the plugin
	# code.
	#print STDERR "Plugin $pluginid not found.\n";
	$session->terminate();
	exit 1;
}
	
my $req_plugin_type = "list/".$ds->confid;
	
unless( $plugin->can_produce( $req_plugin_type ) )
{
	print STDERR "Plugin $pluginid can't process $req_plugin_type data.\n";
	$session->terminate();
	exit 1;
}

if( $plugin->broken )
{
	print STDERR "Plugin $pluginid could not run because:\n";
	print STDERR $plugin->error_message."\n";
	$session->terminate();
	exit 1;
}

if( $scripted )
{
	print "EPRINTS_IMPORT: BEGIN\n";
}

$plugin->input_file(
		dataset=>$ds,
		filename=>$filename,
		user=>$userobj,
	);

my $count = $parse_only ? $handler->{parsed} : $handler->{wrote};

if( $scripted )
{
	print "EPRINTS_IMPORT: DONE $count\n";
}

if( $count > 0 )
{
	if( $noise > 0 )
	{
		if( $parse_only )
		{
			print "Would have imported $count records\n";
		}
		else
		{
			print "Number of records imported: $count\n";
			if( $noise > 1 )
			{
				print join( ",", @{$handler->{ids}})."\n";
			}
		}
	}
	if( @{$handler->{ids}} && defined $userobj && $ds->confid eq "eprint" )
	{
		my $user_id = $userobj->get_id;

		my $list = EPrints::List->new(
			session => $session,
			dataset => $ds,
			ids => $handler->{ids}
		);

		$list->map(
			sub {
				my( $session, $dataset, $eprint ) = @_;
				$eprint->set_value( "userid", $user_id );
				$eprint->commit;
			} );

		$list->dispose;
	}
}

$session->terminate();
exit;
